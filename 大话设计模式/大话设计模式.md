
代码绑着具体类会导致代码更脆弱，更缺乏弹性

多用组合，少用继承
针对接口编程，不针对实现编程
为交互对象之间的松耦合设计而努力
类应该对扩展开放，对修改关闭
依赖抽象，不要依赖具体类

OO设计原则
	
	找到会变化的方面，把他们从不变的部分分离出来

	依赖倒置原则：依赖抽象，不要依赖具体类  不要让高层组件依赖底层组件，不管高层还是底层组件，两者都应该依赖于抽象


策略设计模式
	定义了算法家族，分别封装起来，让他们之间相互替换，此模式让算法的变化不会影响到使用算法的客户

观察者设计模式
	定义了对象之间一对多的依赖关系，当一个对象改变状态时，它的所有依赖者都会受到通知并自动更新

装饰设计模式
	给爱用继承的人一个全新的设计眼界  能在运行时赋予某些对象新的职责

工厂模式(简单工厂、工厂方法、抽象工厂)
简单工厂严格来说并不是一个设计模式，更像是一个编程习惯

	a、面型对象的好处
		通过封装、继承和多态把程序的耦合度降低   可复用、可维护、可扩展就是好程序
	工厂处理创建对象的细节

	工厂方法：工厂方法用来处理对象的创建，并将这样的行为封装在子类中。

	工厂方法模式：定义了一个创建对象的接口，但由子类决定实例化的类是哪一个。工厂方法让类把实例化延迟到子类

	防止违反依赖倒置原则：
		1、不要让变量持有具体类的引用
		2、不要让类派生自具体类(应该派生自抽象)
		3、不要覆盖基类已实现的方法(如果覆盖基类已经实现的方法，那么你的基类就不是一个真正适合被继承的抽象，基类中已经实现的方法，应该由所有的子类共享)

	抽象工厂模式：提供一个接口，用来创建相关或依赖对象的家族，而不需要明确指定具体类 
	
	抽象工厂模式允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么


单例设计模式
	只存在一个对象

命令模式
	将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象

适配器和外观模式
	将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间
	
	与装饰者模式区分：装饰者模式不改变接口，但加入新的职责

	最小密友原则：
		就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：
			1、该对象本身
			2、被当做方法的参数而传递过来的对象
			3、此方法所创建或者实例化的任何对象
			4、对象的任何组件

迭代器模式
	提供一种方法顺序访问一个聚合对象的各个元素，又不暴露其内部的表示

	单一职责原则
		就一个类而言，应该仅有一个引起它变化的原因，类的每一个责任都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域

组合模式
	允许你将对象组合成树形结构来表现“整体/部分”层次结构，组合能以一致的方式处理个别对象以及对象集合

状态模式
	策略设计模式是围绕着可以互换的方法来创建成功业务的
	状态模式是通过改变对象内部的状态来帮助对象控制自己的行为

	策略模式：将可以互换的行为封装起来，然后使用委托的方法，决定使用哪一个行为
	状态模式：封装基于状态的行为，并将行为委托到当前状态
	模板方法：由子类决定实现算法中的某些步骤
代理模式
	控制对象访问
	
	为另一个对象提供一个替身或者占位符以控制对这个对象的访问

复合模式  大名鼎鼎的MVC就属于复合模式
	模式通常被一起使用，并被组合在同一个设计解决方案中  

	复合模式在解决方案中结合两个或多个模式，以解决一半活着重复发生的问题
		
现实世界的模式：
	模式是某种情境下，针对某问题的某种解决方法